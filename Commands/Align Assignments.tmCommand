<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>beforeRunningCommand</key>
	<string>nop</string>
	<key>command</key>
	<string>#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby
# encoding: UTF-8
# Copyright © 2009 Caio Chassot
# Licensed under the WTFPL
# Updated for Ruby 1.8 compatibility by Elia Schito

def alternation(*s)
  s.map(&amp;Regexp.method(:escape)).join("|")
end

# All input is read here.
LINES                = $stdin.readlines
IS_SELECTION         = ENV.key?("TM_SELECTED_TEXT")
CURRENT_LINE         = ENV["TM_LINE_NUMBER"].to_i.pred
CENTER_COLUMN        = ENV['ALIGN_ASSIGNMENTS_CENTER_COLUMN']


# Magic happens here.
# ASSIGNMENT_OPERATORS: There's love for C, ruby, perl, python, javascript, java, even pascal. Hash/Dict assignment included too.
# TROUBLEMAKERS: non-assignment operators that could match as assigment.
ASSIGNMENT_OPERATORS = %w( = -= += /= //= %= *= **= ^= |= &amp;= ||= &amp;&amp;= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= .= x= := ::= =&gt; )
TROUBLEMAKERS        = %w( &lt;= &gt;= &lt;=&gt; == === != =~ )
TROUBLEMAKERS_BEFORE = TROUBLEMAKERS.map { |s| s[/^(.+)=/, 1] }.compact.uniq
TROUBLEMAKERS_AFTER  = TROUBLEMAKERS.map { |s| s[/=(.+)$/, 1] }.compact.uniq
COMMENT_PATTERN      = /^\s*#/

# We'll keep the original Ruby 1.9 regexp as a reference:
#
#     RX_ASSIGNMENT_LINE   = %r[
#       (^.*?)                                          # capture 1 — everything before assignment
#       ( \s*                                           # capture 2 — assignment operator with surrounding spaces
#         (?&lt;!  #{alternation(*TROUBLEMAKERS_BEFORE)} )
#         ( (?: #{alternation(*ASSIGNMENT_OPERATORS)} ) # capture 3 — assignment operator
#         | :(?!\w|:)                                 ) #   special handling for the ':' assignment op (yaml, javascript, etc)
#         (?!   #{alternation(*TROUBLEMAKERS_AFTER )} )
#         \s* )
#     ]x
#
RX_ASSIGNMENT_LINE   = /(^.*?)(\s*[^#{TROUBLEMAKERS_BEFORE.join('')}]((?:#{alternation(*ASSIGNMENT_OPERATORS)})|:(?!\w|:))[^#{TROUBLEMAKERS_AFTER.join ''}]\s*)/

l0, lf = [0, LINES.length.pred]
l0, lf = begin                                                                                                          # try to look up assignment block since we're not in a selection
  ix0  = ixf = %w[ to_i succ pred ].map { |m| CURRENT_LINE.send(m) }.find { |ix| LINES[ix] =~ RX_ASSIGNMENT_LINE }.to_i # assignment must exist in either this line, next, or previous
  ix0  = ix0.pred while ix0 &gt; l0 &amp;&amp; LINES[ix0.pred] =~ RX_ASSIGNMENT_LINE                                               # extend scope to assignments immediately above
  ixf  = ixf.succ while ix0 &lt; lf &amp;&amp; LINES[ixf.succ] =~ RX_ASSIGNMENT_LINE                                               # extend scope to assignments immediately below
  [ix0, ixf]
end unless IS_SELECTION

match_lines  = LINES[l0..lf].map { |s| [s.match(RX_ASSIGNMENT_LINE), s] }.select { |m, s| m and s !~ COMMENT_PATTERN }

len_leftside = match_lines.map   { |m, s| m.begin(2)  }.compact.max
len_operator = match_lines.map   { |m, s| m[3].length if m[3] }.compact.max

match_lines.each do |m, s|
  if m[3] == ':' and !CENTER_COLUMN
    # +1 is for an element less in the array
    s.replace [(m[1] + m[2].strip).ljust(len_leftside+len_operator+1), m.post_match].join(' ')
  else
    s.replace [m[1].to_s.ljust(len_leftside), m[3].to_s.rjust(len_operator), m.post_match].join(' ')
  end
end
puts LINES
</string>
	<key>input</key>
	<string>selection</string>
	<key>keyEquivalent</key>
	<string>~@]</string>
	<key>name</key>
	<string>Align Assignments</string>
	<key>output</key>
	<string>replaceSelectedText</string>
	<key>uuid</key>
	<string>FCBE2215-19CA-470A-8D92-BB0D00491D62</string>
</dict>
</plist>
